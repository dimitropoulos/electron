From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samuel Attard <sattard@slack-corp.com>
Date: Wed, 27 Jan 2021 15:43:35 -0800
Subject: make KeychainPassword::service_name, kApplicationName and
 service_name mutable strings

This should be upstreamable, it's just a type change that makes it
possible for embedders to adjust the service name for the keychain
credential storage.

diff --git a/components/os_crypt/key_storage_keyring.cc b/components/os_crypt/key_storage_keyring.cc
index 409bd27cbc0877634d7d9809575cfa5f60ba04c2..fe363df4d611a895b3a4310bdfe63e38c0891577 100644
--- a/components/os_crypt/key_storage_keyring.cc
+++ b/components/os_crypt/key_storage_keyring.cc
@@ -15,18 +15,18 @@
 
 namespace {
 
-#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-const char kApplicationName[] = "chrome";
-#else
-const char kApplicationName[] = "chromium";
-#endif
-
 const GnomeKeyringPasswordSchema kSchema = {
     GNOME_KEYRING_ITEM_GENERIC_SECRET,
     {{"application", GNOME_KEYRING_ATTRIBUTE_TYPE_STRING}, {nullptr}}};
 
 }  // namespace
 
+#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
+std::string KeyStorageKeyring::kApplicationName = "chrome";
+#else
+std::string KeyStorageKeyring::kApplicationName = "chromium";
+#endif
+
 KeyStorageKeyring::KeyStorageKeyring(
     scoped_refptr<base::SingleThreadTaskRunner> main_thread_runner)
     : main_thread_runner_(main_thread_runner) {}
@@ -49,7 +49,7 @@ base::Optional<std::string> KeyStorageKeyring::GetKeyImpl() {
   gchar* password_c = nullptr;
   GnomeKeyringResult result =
       GnomeKeyringLoader::gnome_keyring_find_password_sync_ptr(
-          &kSchema, &password_c, "application", kApplicationName, nullptr);
+          &kSchema, &password_c, "application", kApplicationName.c_str(), nullptr);
   if (result == GNOME_KEYRING_RESULT_OK) {
     password = password_c;
     GnomeKeyringLoader::gnome_keyring_free_password_ptr(password_c);
@@ -71,7 +71,7 @@ base::Optional<std::string> KeyStorageKeyring::AddRandomPasswordInKeyring() {
   GnomeKeyringResult result =
       GnomeKeyringLoader::gnome_keyring_store_password_sync_ptr(
           &kSchema, nullptr /* default keyring */, KeyStorageLinux::kKey,
-          password.c_str(), "application", kApplicationName, nullptr);
+          password.c_str(), "application", kApplicationName.c_str(), nullptr);
   if (result != GNOME_KEYRING_RESULT_OK) {
     VLOG(1) << "OSCrypt failed to store generated password to gnome-keyring";
     return base::nullopt;
diff --git a/components/os_crypt/key_storage_keyring.h b/components/os_crypt/key_storage_keyring.h
index 6406f2825997e0166defd7dd1457c734aa5ee6c4..b0bd7a04fa093a3dbc5a9a3029347aa1a8de5963 100644
--- a/components/os_crypt/key_storage_keyring.h
+++ b/components/os_crypt/key_storage_keyring.h
@@ -23,6 +23,7 @@ class COMPONENT_EXPORT(OS_CRYPT) KeyStorageKeyring : public KeyStorageLinux {
   explicit KeyStorageKeyring(
       scoped_refptr<base::SingleThreadTaskRunner> main_thread_runner);
   ~KeyStorageKeyring() override;
+  static std::string kApplicationName;
 
  protected:
   // KeyStorageLinux
diff --git a/components/os_crypt/key_storage_libsecret.cc b/components/os_crypt/key_storage_libsecret.cc
index 312570612ccb6ec4480a6f8d4a74accf5ba79ff8..c82c1e6370d5b79d7352c5f49ff15640ac6c39d7 100644
--- a/components/os_crypt/key_storage_libsecret.cc
+++ b/components/os_crypt/key_storage_libsecret.cc
@@ -14,12 +14,6 @@
 
 namespace {
 
-#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-const char kApplicationName[] = "chrome";
-#else
-const char kApplicationName[] = "chromium";
-#endif
-
 const SecretSchema kKeystoreSchemaV2 = {
     "chrome_libsecret_os_crypt_password_v2",
     SECRET_SCHEMA_DONT_MATCH_NAME,
@@ -64,6 +58,12 @@ void AnalyseKeyHistory(GList* secret_items) {
 
 }  // namespace
 
+#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
+std::string KeyStorageLibsecret::kApplicationName = "chrome";
+#else
+std::string KeyStorageLibsecret::kApplicationName = "chromium";
+#endif
+
 base::Optional<std::string>
 KeyStorageLibsecret::AddRandomPasswordInLibsecret() {
   std::string password;
@@ -71,7 +71,7 @@ KeyStorageLibsecret::AddRandomPasswordInLibsecret() {
   GError* error = nullptr;
   bool success = LibsecretLoader::secret_password_store_sync(
       &kKeystoreSchemaV2, nullptr, KeyStorageLinux::kKey, password.c_str(),
-      nullptr, &error, "application", kApplicationName, nullptr);
+      nullptr, &error, "application", kApplicationName.c_str(), nullptr);
   if (error) {
     VLOG(1) << "Libsecret lookup failed: " << error->message;
     g_error_free(error);
@@ -88,7 +88,7 @@ KeyStorageLibsecret::AddRandomPasswordInLibsecret() {
 
 base::Optional<std::string> KeyStorageLibsecret::GetKeyImpl() {
   LibsecretAttributesBuilder attrs;
-  attrs.Append("application", kApplicationName);
+  attrs.Append("application", kApplicationName.c_str());
 
   LibsecretLoader::SearchHelper helper;
   helper.Search(&kKeystoreSchemaV2, attrs.Get(),
diff --git a/components/os_crypt/key_storage_libsecret.h b/components/os_crypt/key_storage_libsecret.h
index e59a2a1b5a776010556613ad63391c000ef977a4..b74067a7e09a5744d5ce562fa2c201ff8e295d5b 100644
--- a/components/os_crypt/key_storage_libsecret.h
+++ b/components/os_crypt/key_storage_libsecret.h
@@ -17,6 +17,7 @@ class COMPONENT_EXPORT(OS_CRYPT) KeyStorageLibsecret : public KeyStorageLinux {
  public:
   KeyStorageLibsecret() = default;
   ~KeyStorageLibsecret() override = default;
+  static std::string kApplicationName;
 
  protected:
   // KeyStorageLinux
diff --git a/components/os_crypt/key_storage_linux.cc b/components/os_crypt/key_storage_linux.cc
index 2e388de793af588722c857cd7b896df9734f2b6e..0cb38033028c86e568aadb69e4efc29c3099acfd 100644
--- a/components/os_crypt/key_storage_linux.cc
+++ b/components/os_crypt/key_storage_linux.cc
@@ -152,6 +152,7 @@ std::unique_ptr<KeyStorageLinux> KeyStorageLinux::CreateServiceInternal(
 #if defined(USE_LIBSECRET)
   if (selected_backend == os_crypt::SelectedLinuxBackend::GNOME_ANY ||
       selected_backend == os_crypt::SelectedLinuxBackend::GNOME_LIBSECRET) {
+    KeyStorageLibsecret::kApplicationName = config.product_name;
     key_storage = std::make_unique<KeyStorageLibsecret>();
     if (key_storage->WaitForInitOnTaskRunner()) {
       VLOG(1) << "OSCrypt using Libsecret as backend.";
@@ -164,6 +165,7 @@ std::unique_ptr<KeyStorageLinux> KeyStorageLinux::CreateServiceInternal(
 #if defined(USE_KEYRING)
   if (selected_backend == os_crypt::SelectedLinuxBackend::GNOME_ANY ||
       selected_backend == os_crypt::SelectedLinuxBackend::GNOME_KEYRING) {
+    KeyStorageKeyring::kApplicationName = config.product_name;
     key_storage =
         std::make_unique<KeyStorageKeyring>(config.main_thread_runner);
     if (key_storage->WaitForInitOnTaskRunner()) {
diff --git a/components/os_crypt/keychain_password_mac.h b/components/os_crypt/keychain_password_mac.h
index 6fda0244667c4eb5d1abb973f4b72d9c59ed2165..45c815620e3e095366de8586ef6a6872b8e04c0b 100644
--- a/components/os_crypt/keychain_password_mac.h
+++ b/components/os_crypt/keychain_password_mac.h
@@ -28,8 +28,8 @@ class COMPONENT_EXPORT(OS_CRYPT) KeychainPassword {
   std::string GetPassword() const;
 
   // The service and account names used in Chrome's Safe Storage keychain item.
-  static COMPONENT_EXPORT(OS_CRYPT) const char service_name[];
-  static COMPONENT_EXPORT(OS_CRYPT) const char account_name[];
+  static COMPONENT_EXPORT(OS_CRYPT) std::string service_name;
+  static COMPONENT_EXPORT(OS_CRYPT) std::string account_name;
 
  private:
   const crypto::AppleKeychain& keychain_;
diff --git a/components/os_crypt/keychain_password_mac.mm b/components/os_crypt/keychain_password_mac.mm
index 6654c46eb0af784a3a2ff64569d5d1931b9fae30..c8e4e7a74be14b2e2724a01b411f02b27ab99752 100644
--- a/components/os_crypt/keychain_password_mac.mm
+++ b/components/os_crypt/keychain_password_mac.mm
@@ -48,11 +48,11 @@
 // the encryption keyword.  So as to not lose encrypted data when system
 // locale changes we DO NOT LOCALIZE.
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-const char KeychainPassword::service_name[] = "Chrome Safe Storage";
-const char KeychainPassword::account_name[] = "Chrome";
+std::string KeychainPassword::service_name = "Chrome Safe Storage";
+std::string KeychainPassword::account_name = "Chrome";
 #else
-const char KeychainPassword::service_name[] = "Chromium Safe Storage";
-const char KeychainPassword::account_name[] = "Chromium";
+std::string KeychainPassword::service_name = "Chromium Safe Storage";
+std::string KeychainPassword::account_name = "Chromium";
 #endif
 
 KeychainPassword::KeychainPassword(const AppleKeychain& keychain)
@@ -64,7 +64,7 @@
   UInt32 password_length = 0;
   void* password_data = nullptr;
   OSStatus error = keychain_.FindGenericPassword(
-      strlen(service_name), service_name, strlen(account_name), account_name,
+      service_name.length(), service_name.c_str(), account_name.length(), account_name.c_str(),
       &password_length, &password_data, nullptr);
 
   if (error == noErr) {
